<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web Edition - Isometric</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #555;
            backdrop-filter: blur(5px);
        }

        #hud h3 {
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .stats {
            display: flex;
            gap: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 200px;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 5px;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        .chat-msg {
            font-size: 14px;
            margin-bottom: 4px;
            text-shadow: 1px 1px 0 #000;
        }

        #chat-input {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 4px;
            width: 100%;
        }

        #inventory-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 8px;
            pointer-events: auto;
        }

        .inv-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            margin: 0 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: border-color 0.2s;
        }

        .inv-slot.active {
            border-color: white;
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="ui">
            <div id="hud">
                <h3>Isometric World</h3>
                <div class="stats">
                    <div class="stat-item">
                        <div>Chunks</div>
                        <div id="chunk-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div>Position</div>
                        <div id="pos-display">0, 0</div>
                    </div>
                </div>
            </div>

            <div id="chat-container">
                <div id="chat-messages"></div>
                <input type="text" id="chat-input" placeholder="Press Enter to chat...">
            </div>

            <div id="inventory-bar">
                <div class="inv-slot active" data-type="grass" title="Grass">ðŸŸ©</div>
                <div class="inv-slot" data-type="stone" title="Stone">ðŸª¨</div>
                <div class="inv-slot" data-type="dirt" title="Dirt">ðŸŸ«</div>
                <div class="inv-slot" data-type="wood" title="Wood">ðŸªµ</div>
            </div>

            <div id="controls-hint">
                <p><strong>WASD</strong> to Move</p>
                <p><strong>Space</strong> to Jump</p>
                <p><strong>Click</strong> to Mine/Place</p>
                <p><strong>Scroll</strong> to Zoom</p>
            </div>
            <div id="loading">Generating Terrain...</div>
        </div>
    </div>

    <!-- Load Socket.io and Multiplayer Client -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="../../assets/js/multiplayer.js"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';

        // --- Perlin Noise Implementation ---
        const PERLIN_YWRAPB = 4; const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
        const PERLIN_ZWRAPB = 8; const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
        const PERLIN_SIZE = 4095;
        let perlin_octaves = 4; let perlin_amp_falloff = 0.5;
        const perlin = new Float32Array(PERLIN_SIZE + 1);
        for (let i = 0; i <= PERLIN_SIZE; i++) perlin[i] = Math.random();

        function noise(x) {
            let xi = Math.floor(x);
            let xf = x - xi;
            let n1, n2, n3;
            let r = 0;
            let ampl = 0.5;
            for (let o = 0; o < perlin_octaves; o++) {
                let of = xi + (xf * (1 << o));
                let rxf = of - Math.floor(of);
                n1 = (Math.floor(of) & PERLIN_SIZE);
                n1 += (n1 >> PERLIN_YWRAPB) & PERLIN_SIZE;
                n2 = n1 + 1;
                if (n2 > PERLIN_SIZE) n2 -= PERLIN_SIZE;
                n3 = perlin[n1] * (1 - rxf) + perlin[n2] * rxf;
                r += n3 * ampl;
                ampl *= perlin_amp_falloff;
            }
            return r;
        }

        function noise2d(x, y) {
            return (noise(x * 0.1 + y * 0.1) + noise(x * 0.3 - y * 0.2) * 0.5) / 1.5;
        }

        // --- Game Variables ---
        let scene, camera, renderer;
        let player;
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 3;
        const BLOCK_SIZE = 1;

        let chunks = {};
        let activeChunks = [];
        let otherPlayers = {}; // { id: mesh }

        // Multiplayer
        const mp = new MultiplayerClient();
        const username = localStorage.getItem('username') || 'Guest' + Math.floor(Math.random() * 1000);

        // Player state
        let playerPos = new THREE.Vector3(0, 10, 0);
        let playerVelocity = new THREE.Vector3();
        const SPEED = 0.15;
        const JUMP_FORCE = 0.4;
        const GRAVITY = 0.02;

        // Interaction
        let selectedBlockType = 'grass';
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // Inputs
        const keys = { w: false, a: false, s: false, d: false, space: false };

        // Materials
        const materials = {
            grass: new THREE.MeshStandardMaterial({ color: 0x5da64e, roughness: 0.8 }),
            dirt: new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 1.0 }),
            stone: new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.6 }),
            sand: new THREE.MeshStandardMaterial({ color: 0xe6cc80, roughness: 0.9 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 }),
            leaves: new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 }),
            player: new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 }),
            otherPlayer: new THREE.MeshStandardMaterial({ color: 0x4444ff, roughness: 0.4 })
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 500;
            const d = 50;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);

            // Camera (Isometric)
            const aspect = window.innerWidth / window.innerHeight;
            const camD = 20;
            camera = new THREE.OrthographicCamera(-camD * aspect, camD * aspect, camD, -camD, 1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);

            // Player Setup
            const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            player = new THREE.Mesh(geometry, materials.player);
            player.position.copy(playerPos);
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', (e) => handleKey(e, true));
            window.addEventListener('keyup', (e) => handleKey(e, false));
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);

            // Inventory
            document.querySelectorAll('.inv-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('active'));
                    slot.classList.add('active');
                    selectedBlockType = slot.dataset.type;
                });
            });

            // Chat
            const chatInput = document.getElementById('chat-input');
            chatInput.addEventListener('keydown', (e) => {
                e.stopPropagation(); // Prevent walking while typing
                if (e.key === 'Enter' && chatInput.value.trim()) {
                    mp.sendChat(chatInput.value.trim());
                    chatInput.value = '';
                }
            });

            // Multiplayer Setup
            setupMultiplayer();

            animate();
        }

        function setupMultiplayer() {
            mp.onPlayerUpdate = (data) => {
                if (data.id === mp.myId) return;

                let other = otherPlayers[data.id];
                if (!other) {
                    const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                    other = new THREE.Mesh(geo, materials.otherPlayer);
                    scene.add(other);
                    otherPlayers[data.id] = other;
                }
                other.position.set(data.x, data.y, data.z);

                // Keep name tag logic simple for now (could be added)
            };

            mp.onPlayerLeft = (id) => {
                if (otherPlayers[id]) {
                    scene.remove(otherPlayers[id]);
                    delete otherPlayers[id];
                }
            };

            mp.onChat = (data) => {
                const chatBox = document.getElementById('chat-messages');
                const msg = document.createElement('div');
                msg.className = 'chat-msg';
                msg.innerHTML = `<span style="color: #00f260; font-weight: bold;">${data.username}:</span> ${data.message}`;
                chatBox.appendChild(msg);
                chatBox.scrollTop = chatBox.scrollHeight;
            };

            mp.connect();
            mp.joinRoom('minecraft-lobby', { username: username });
        }

        function onMouseMove(event) {
            // Update mouse coordinates for raycasting
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(event) {
            if (event.target.id !== 'container' && event.target.tagName !== 'CANVAS') return;

            raycaster.setFromCamera(mouse, camera);

            // Get all block meshes from chunks
            // Optimization: Only check relevant chunks? For now check all
            let allBlocks = [];
            for (let key in chunks) {
                // If using InstancedMesh, this is harder. But we used Group of Meshes in simple logic.
                allBlocks.push(...chunks[key].children);
            }

            const intersects = raycaster.intersectObjects(allBlocks);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const type = event.button === 0 ? 'break' : 'place'; // Left click break, Right click place

                if (type === 'break') {
                    // Remove block
                    hit.object.parent.remove(hit.object);
                } else if (type === 'place') {
                    // Place block
                    const normal = hit.face.normal;
                    const pos = hit.point.clone().add(normal.multiplyScalar(0.5)).floor().addScalar(0.5);

                    const geo = new THREE.BoxGeometry(1, 1, 1);
                    const mat = materials[selectedBlockType] || materials.grass;
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(pos);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;

                    // Add to same parent as hit object (the chunk group)
                    hit.object.parent.add(mesh);
                }
            }
        }

        function handleKey(e, isDown) {
            if (document.activeElement.id === 'chat-input') return;
            const code = e.code.toLowerCase();
            if (code === 'keyw') keys.w = isDown;
            if (code === 'keya') keys.a = isDown;
            if (code === 'keys') keys.s = isDown;
            if (code === 'keyd') keys.d = isDown;
            if (code === 'space') keys.space = isDown;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Chunk Loading State
        let loadingChunks = new Set();

        function getChunkKey(cx, cz) { return `${cx},${cz}`; }

        async function loadChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (chunks[key] || loadingChunks.has(key)) return;

            loadingChunks.add(key);

            try {
                const res = await fetch(`/api/game/chunk?x=${cx}&z=${cz}`);
                const json = await res.json();

                if (json.data) {
                    // Load from save
                    createChunkFromData(cx, cz, json.data);
                } else {
                    // Generate new
                    generateChunk(cx, cz);
                }
            } catch (err) {
                console.error('Chunk load error, falling back to gen', err);
                generateChunk(cx, cz);
            } finally {
                loadingChunks.delete(key);
            }
        }

        function createChunkFromData(cx, cz, blocks) {
            const chunkGroup = new THREE.Group();
            const geo = new THREE.BoxGeometry(1, 1, 1);

            blocks.forEach(b => {
                const mat = materials[b.type] || materials.grass;
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(b.x, b.y, b.z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData.type = b.type;
                chunkGroup.add(mesh);
            });

            scene.add(chunkGroup);
            chunks[getChunkKey(cx, cz)] = chunkGroup;
            document.getElementById('chunk-count').innerText = Object.keys(chunks).length;
        }

        function saveChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            const group = chunks[key];
            if (!group) return;

            const blocks = [];
            group.children.forEach(mesh => {
                blocks.push({
                    x: mesh.position.x,
                    y: mesh.position.y,
                    z: mesh.position.z,
                    type: mesh.userData.type || 'grass'
                });
            });

            fetch('/api/game/chunk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ x: cx, z: cz, data: blocks })
            }).catch(e => console.error('Save failed', e));
        }

        function getTerrainHeight(x, z) {
            const scale = 0.05;
            const h = noise2d(x * scale, z * scale);
            return Math.floor(h * 15) + 5;
        }

        function generateChunk(cx, cz) {
            const chunkGroup = new THREE.Group();
            const geo = new THREE.BoxGeometry(1, 1, 1);

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let z = 0; z < CHUNK_SIZE; z++) {
                    const worldX = cx * CHUNK_SIZE + x;
                    const worldZ = cz * CHUNK_SIZE + z;
                    const height = getTerrainHeight(worldX, worldZ);

                    // Surface
                    const mesh = new THREE.Mesh(geo, materials.grass);
                    mesh.position.set(worldX, height, worldZ);
                    mesh.receiveShadow = true;
                    mesh.userData.type = 'grass';
                    chunkGroup.add(mesh);

                    // Dirt below
                    const dirtHeight = Math.max(1, height - 2);
                    for (let y = height - 1; y >= dirtHeight; y--) {
                        const dMesh = new THREE.Mesh(geo, materials.dirt);
                        dMesh.position.set(worldX, y, worldZ);
                        dMesh.castShadow = true;
                        dMesh.receiveShadow = true;
                        dMesh.userData.type = 'dirt';
                        chunkGroup.add(dMesh);
                    }

                    // Tree chance
                    if (height > 6 && Math.random() > 0.98) {
                        createTree(chunkGroup, worldX, height + 1, worldZ);
                    }
                }
            }
            scene.add(chunkGroup);
            chunks[getChunkKey(cx, cz)] = chunkGroup;
            document.getElementById('chunk-count').innerText = Object.keys(chunks).length;

            // Auto-save generated chunk? Optional. Let's not spam server for interactions only.
            // saveChunk(cx, cz); 
            return chunkGroup;
        }

        function createTree(group, x, y, z) {
            // Trunk
            const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.6, 3, 0.6), materials.wood);
            trunk.position.set(x, y + 1, z);
            trunk.castShadow = true;
            trunk.userData.type = 'wood';
            group.add(trunk);

            // Leaves
            const leaves = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2, 2.5), materials.leaves);
            leaves.position.set(x, y + 3, z);
            leaves.castShadow = true;
            leaves.userData.type = 'leaves';
            group.add(leaves);
        }

        function updateChunks() {
            const currentChunkX = Math.floor(player.position.x / CHUNK_SIZE);
            const currentChunkZ = Math.floor(player.position.z / CHUNK_SIZE);

            // Load chunks around player
            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const cx = currentChunkX + x;
                    const cz = currentChunkZ + z;
                    loadChunk(cx, cz);
                }
            }
        }

        function checkCollisions(newPos) {
            const groundHeight = getTerrainHeight(newPos.x, newPos.z);
            if (newPos.y - 0.9 < groundHeight + 0.5) {
                newPos.y = groundHeight + 0.5 + 0.9;
                playerVelocity.y = 0;
                return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Movement
            const moveSpeed = SPEED;
            let dx = 0; let dz = 0;
            if (keys.w) { dx -= 1; dz -= 1; }
            if (keys.s) { dx += 1; dz += 1; }
            if (keys.a) { dx -= 1; dz += 1; }
            if (keys.d) { dx += 1; dz -= 1; }

            if (dx !== 0 || dz !== 0) {
                const len = Math.sqrt(dx * dx + dz * dz);
                dx /= len; dz /= len;
                player.position.x += dx * moveSpeed;
                player.position.z += dz * moveSpeed;

                // Sync position
                mp.sendUpdate({ x: player.position.x, y: player.position.y, z: player.position.z });
            }

            // Physics
            playerVelocity.y -= GRAVITY;
            player.position.y += playerVelocity.y;
            const onGround = checkCollisions(player.position);
            if (onGround && keys.space) {
                playerVelocity.y = JUMP_FORCE;
            }

            // Camera
            camera.position.x = player.position.x + 20;
            camera.position.z = player.position.z + 20;
            camera.position.y = player.position.y + 20;
            camera.lookAt(player.position);

            updateChunks();

            document.getElementById('pos-display').innerText = `${Math.round(player.position.x)}, ${Math.round(player.position.z)}`;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>

</html> } else if (e.button === 2) {
// Place block on right click
const faceNormal = face.normal;
const newX = Math.round(x + faceNormal.x);
const newY = Math.round(y + faceNormal.y);
const newZ = Math.round(z + faceNormal.z);
addBlock(newX, newY, newZ, currentBlockType);
blocksPlaced++;
updateStatsUI();
}
}

function handleSwordAttack() {
if (attackCooldown > 0) return;

raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
const intersects = raycaster.intersectObjects(mobs.map(m => m.mesh));

if (intersects.length > 0) {
const mobObject = intersects[0].object;
const mob = mobs.find(m => m.mesh === mobObject || m.mesh.children.includes(mobObject));

if (mob) {
// Apply damage to mob
const damage = 15 + Math.floor(Math.random() * 20);
mob.health -= damage;

// Show damage indicator
const damageElem = document.createElement('div');
damageElem.className = 'damage';
damageElem.textContent = `-${damage}`;
damageElem.style.left = `${50 + (Math.random() - 0.5) * 30}%`;
damageElem.style.top = `${50 + (Math.random() * 20)}%`;
document.getElementById('ui').appendChild(damageElem);

// Remove damage indicator after animation
setTimeout(() => {
if (damageElem.parentNode) {
damageElem.parentNode.removeChild(damageElem);
}
}, 1500);

// Update mob UI
document.getElementById('mob-health').style.display = 'block';
document.getElementById('mob-health-value').textContent = `${Math.max(0, Math.floor(mob.health / mob.originalHealth *
100))}%`;

// Check if mob died
if (mob.health <= 0) { scene.remove(mob.mesh); mobs.splice(mobs.indexOf(mob), 1); // Grant XP to player const
    xpGained=10 + Math.floor(Math.random() * 15); addExp(xpGained);
    document.getElementById('mob-health').style.display='none' ; mobsCount--; updateStatsUI(); // Sometimes spawn a new
    monster if (mobs.length < 15 && Math.random()> 0.5) {
    const cameraPos = camera.position;
    addMonster(
    cameraPos.x + (Math.random() - 0.5) * 30,
    cameraPos.y,
    cameraPos.z + (Math.random() - 0.5) * 30
    );
    }
    }

    // Attack cooldown
    attackCooldown = 0.5;
    }
    }
    }

    function addExp(amount) {
    playerExp += amount;
    if (playerExp >= expToNextLevel) {
    playerExp = playerExp - expToNextLevel;
    playerLevel++;
    expToNextLevel = Math.floor(expToNextLevel * 1.3);
    document.getElementById('level').textContent = `Level ${playerLevel}`;
    }

    const expPercent = (playerExp / expToNextLevel) * 100;
    document.getElementById('exp-fill').style.width = `${expPercent}%`;
    }

    function animateDayNight(delta) {
    // Toggle day/night every 30 seconds
    if (Math.sin(clock.elapsedTime * 0.1) > 0) {
    if (!dayTime) {
    dayTime = true;
    document.getElementById('time-text').textContent = 'Day';
    document.querySelector('.time-icon').textContent = 'â˜€ï¸';
    scene.background = new THREE.Color(0x87CEEB);
    sun.visible = true;
    moon.visible = false;
    }
    } else {
    if (dayTime) {
    dayTime = false;
    document.getElementById('time-text').textContent = 'Night';
    document.querySelector('.time-icon').textContent = 'ðŸŒ™';
    scene.background = new THREE.Color(0x0c1445);
    sun.visible = false;
    moon.visible = true;
    }
    }
    }

    function updateStatsUI() {
    document.getElementById('chunk-count').textContent = chunksLoaded;
    document.getElementById('blocks-count').textContent = blocksPlaced;
    document.getElementById('mobs-count').textContent = mobsCount;
    }

    function updateMonsterAI(delta) {
    mobs.forEach(mob => {
    if (!mob.mesh) return;

    // Get the mob position
    const mobPos = mob.mesh.position;

    // Calculate direction to player
    const direction = new THREE.Vector3();
    direction.subVectors(camera.position, mobPos).normalize();

    // Move towards the player
    mob.mesh.position.add(direction.multiplyScalar(mob.speed * delta * 30));

    // Rotate to face player
    mob.mesh.lookAt(camera.position);

    // Maintain vertical alignment
    mob.mesh.rotation.x = 0;
    mob.mesh.rotation.z = 0;

    // Check for collision with player
    const distance = mobPos.distanceTo(camera.position);
    if (distance < 2) { playerHealth -=mob.damage * delta;
        document.getElementById('health-fill').style.width=`${Math.max(0, playerHealth)}%`; if (playerHealth <=0) { //
        Player died - reset playerHealth=100; document.getElementById('health-fill').style.width=`100%`;
        camera.position.set(32, 20, 32); } } }); } function showBlockName(name) { const
        nameElem=document.getElementById('block-name'); nameElem.textContent=name; nameElem.style.opacity=1;
        setTimeout(()=> {
        nameElem.style.opacity = 0;
        }, 2000);
        }

        function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
        requestAnimationFrame(animate);

        const delta = Math.min(0.1, clock.getDelta());

        // UI animations
        document.getElementById('level').textContent = `Level ${playerLevel}`;

        if (!controls.isLocked) {
        // Pre-game animations
        const camPos = camera.position;
        const time = clock.getElapsedTime();
        camPos.x = 32 + Math.sin(time * 0.2) * 10;
        camPos.z = 32 + Math.cos(time * 0.3) * 10;
        camera.lookAt(WORLD_SIZE/2, 10, WORLD_SIZE/2);
        renderer.render(scene, camera);
        return;
        }

        // Gameplay updates
        updatePlayerPosition(delta);
        updateMonsterAI(delta);
        animateDayNight(delta);

        // Apply gravity
        playerVelocity.y -= 0.005;
        camera.position.y += playerVelocity.y;

        // Ground collision detection
        raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
        const groundHit = raycaster.intersectObjects(Object.values(world).map(b => b.mesh))[0];
        if (groundHit && groundHit.distance < 2) { camera.position.y=groundHit.point.y + 1.8;
            playerVelocity.y=Math.max(0, playerVelocity.y); } // Constrain player to map camera.position.x=Math.max(1,
            Math.min(WORLD_SIZE - 1, camera.position.x)); camera.position.y=Math.max(1, Math.min(80,
            camera.position.y)); camera.position.z=Math.max(1, Math.min(WORLD_SIZE - 1, camera.position.z)); // Reduce
            attack cooldown if (attackCooldown> 0) attackCooldown -= delta;

            // Render the scene
            renderer.render(scene, camera);
            }

            // Start the game
            init();
            </script>
            </body>

            </html>