<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Web Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #1a1a1a;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
        
        #ui {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
        }
        
        .cross-symbol {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #health-bar {
            position: absolute;
            bottom: 120px;
            left: 30px;
            width: 200px;
            height: 24px;
            background: rgba(100, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0800, #ff5e00);
            transition: width 0.2s;
        }
        
        #exp-bar {
            position: absolute;
            bottom: 90px;
            left: 30px;
            width: 200px;
            height: 14px;
            background: rgba(0, 50, 100, 0.5);
            border: 2px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #exp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #008cff, #00d9ff);
            transition: width 0.3s;
        }
        
        #level {
            position: absolute;
            bottom: 65px;
            left: 35px;
            font-size: 18px;
            color: #00aeff;
            text-shadow: 0 0 5px rgba(0, 174, 255, 0.7);
        }
        
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 8px;
            backdrop-filter: blur(5px);
        }
        
        .inventory-slot {
            width: 46px;
            height: 46px;
            margin: 0 4px;
            background: rgba(100, 100, 100, 0.4);
            border: 2px solid #777;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .inventory-slot.selected {
            background: rgba(150, 150, 150, 0.6);
            border-color: #ffcc00;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 230, 0, 0.5);
        }
        
        .inventory-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        
        #block-name {
            position: absolute;
            bottom: 85px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }
        
        #tooltip {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-size: 20px;
            border: 3px solid #4CAF50;
            backdrop-filter: blur(8px);
            max-width: 500px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        #tooltip h1 {
            color: #4CAF50;
            font-size: 32px;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }
        
        #tooltip p {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        #tooltip button {
            background: linear-gradient(to bottom, #44c767, #2d8e2a);
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            color: white;
            font-weight: bold;
            margin-top: 20px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 18px;
            transition: all 0.2s;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
        }
        
        #tooltip button:hover {
            background: linear-gradient(to bottom, #55d777, #3dae3a);
            transform: scale(1.05);
        }
        
        #mob-health {
            position: absolute;
            top: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 20px;
            display: none;
            border: 1px solid #f33;
            backdrop-filter: blur(5px);
        }
        
        .damage {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #ff5555;
            text-shadow: 0 0 3px #000;
            animation: floatUp 1.5s forwards;
            pointer-events: none;
        }
        
        #day-night {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.4);
            padding: 10px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        .time-icon {
            font-size: 28px;
            margin-right: 10px;
        }
        
        #time-text {
            font-size: 16px;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translate(0, 0);
            }
            100% {
                opacity: 0;
                transform: translate(0, -50px);
            }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #555;
            backdrop-filter: blur(5px);
        }
        
        #hud h3 {
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .stats {
            display: flex;
            margin-top: 8px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            margin-right: 15px;
        }
        
        @media (max-width: 768px) {
            #inventory {
                bottom: 10px;
                padding: 6px;
            }
            
            .inventory-slot {
                width: 40px;
                height: 40px;
            }
            
            #health-bar, #exp-bar {
                left: 20px;
            }
            
            #level {
                left: 25px;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="crosshair">
                <div class="cross-symbol">+</div>
            </div>
            
            <div id="health-bar">
                <div id="health-fill" style="width: 100%;"></div>
            </div>
            
            <div id="exp-bar">
                <div id="exp-fill" style="width: 0%;"></div>
            </div>
            
            <div id="level">Level 1</div>
            
            <div id="inventory">
                <div class="inventory-slot selected" data-block="grass" data-count="99">
                    <span class="block-icon">üåø</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="dirt" data-count="99">
                    <span class="block-icon">üü´</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="stone" data-count="99">
                    <span class="block-icon">‚¨ú</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="wood" data-count="99">
                    <span class="block-icon">üü§</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="sand" data-count="99">
                    <span class="block-icon">üü®</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="diamond" data-count="99">
                    <span class="block-icon">üíé</span>
                    <div class="inventory-count">99</div>
                </div>
                <div class="inventory-slot" data-block="sword">
                    <span class="block-icon">‚öîÔ∏è</span>
                </div>
            </div>
            
            <div id="block-name">Grass Block</div>
            
            <div id="tooltip">
                <h1>MINECRAFT WEB EDITION</h1>
                <p>Experience the magic of Minecraft directly in your browser!</p>
                <div style="display: flex; justify-content: space-around; margin: 20px 0;">
                    <div style="text-align: left;">
                        <p><strong>Movement:</strong> WASD</p>
                        <p><strong>Jump:</strong> Spacebar</p>
                        <p><strong>Sprint:</strong> Hold Left Shift</p>
                    </div>
                    <div style="text-align: left;">
                        <p><strong>Mine/Attack:</strong> Left Click</p>
                        <p><strong>Place Blocks:</strong> Right Click</p>
                        <p><strong>Switch Items:</strong> Numbers 1-7</p>
                    </div>
                </div>
                <p style="margin-top:15px; color:#FFD700;">Defeat monsters to gain experience and level up!</p>
                <button id="start-btn">START ADVENTURE</button>
            </div>
            
            <div id="mob-health">
                Creeper: <span id="mob-health-value">100%</span>
            </div>
            
            <div id="day-night">
                <div class="time-icon">‚òÄÔ∏è</div>
                <div id="time-text">Day</div>
            </div>
            
            <div id="hud">
                <h3>Game Stats</h3>
                <div class="stats">
                    <div class="stat-item">
                        <div>Chunks Loaded</div>
                        <div id="chunk-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div>Blocks Placed</div>
                        <div id="blocks-count">0</div>
                    </div>
                    <div class="stat-item">
                        <div>Monsters</div>
                        <div id="mobs-count">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { PointerLockControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/PointerLockControls.js';
        
        // Game variables - optimized for better performance
        let scene, camera, renderer, controls;
        let world = {};
        const BLOCK_SIZE = 1;
        const WORLD_SIZE = 64;
        const CHUNK_SIZE = 16;
        const VIEW_DISTANCE = 4;
        
        // Player state
        let playerVelocity = new THREE.Vector3();
        let playerHealth = 100;
        let playerLevel = 1;
        let playerExp = 0;
        let expToNextLevel = 100;
        
        // Game stats
        let chunksLoaded = 0;
        let blocksPlaced = 0;
        let mobsCount = 0;
        
        // Game objects
        let mobs = [];
        let lastChunkX = null, lastChunkZ = null;
        let clock = new THREE.Clock();
        let sun, moon, ambientLight;
        let dayTime = true;
        let gameStarted = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let keyboard = {};
        let attackCooldown = 0;
        
        // Block information
        const BLOCK_DATA = {
            grass: { icon: 'üåø', color: 0x7cfc00, name: 'Grass Block' },
            dirt: { icon: 'üü´', color: 0x8B4513, name: 'Dirt Block' },
            stone: { icon: '‚¨ú', color: 0x808080, name: 'Stone Block' },
            wood: { icon: 'üü§', color: 0x8B4513, name: 'Wood Block' },
            sand: { icon: 'üü®', color: 0xf4d03f, name: 'Sand Block' },
            diamond: { icon: 'üíé', color: 0x1e90ff, name: 'Diamond Ore' }
        };
        
        // Initialization function
        async function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(32, 20, 32);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Sun and Moon lighting
            sun = new THREE.DirectionalLight(0xfff4e6, 1.0);
            sun.position.set(100, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.visible = true;
            scene.add(sun);
            
            moon = new THREE.DirectionalLight(0xcfd9ff, 0.4);
            moon.position.set(-100, 100, -50);
            moon.visible = false;
            scene.add(moon);
            
            // Create controls
            controls = new PointerLockControls(camera, document.body);
            
            // Initialize world
            generateWorld();
            createSky();
            
            // UI event handlers
            document.getElementById('start-btn').addEventListener('click', startGame);
            
            // Inventory handlers
            const inventorySlots = document.querySelectorAll('.inventory-slot');
            inventorySlots.forEach((slot, index) => {
                slot.addEventListener('click', () => {
                    if (!gameStarted) return;
                    inventorySlots.forEach(s => s.classList.remove('selected'));
                    slot.classList.add('selected');
                    const blockType = slot.getAttribute('data-block');
                    if (blockType) {
                        currentBlockType = blockType;
                        // Show block name
                        const name = BLOCK_DATA[blockType]?.name || 'Sword';
                        showBlockName(name);
                    }
                });
                
                // Add keyboard shortcut (1-7)
                document.addEventListener('keydown', (e) => {
                    if (e.key === (index + 1).toString() && controls.isLocked) {
                        inventorySlots.forEach(s => s.classList.remove('selected'));
                        slot.classList.add('selected');
                        const blockType = slot.getAttribute('data-block');
                        if (blockType) {
                            currentBlockType = blockType;
                            const name = BLOCK_DATA[blockType]?.name || 'Sword';
                            showBlockName(name);
                        }
                    }
                });
            });
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
            
            // Movement key handlers
            window.addEventListener('keydown', (e) => {
                keyboard[e.code] = true;
                // Check for jump key
                if (e.code === 'Space' && controls.isLocked) {
                    raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
                    if (raycaster.intersectObjects(Object.values(world).map(b => b.mesh))[0]?.distance < 5) {
                        playerVelocity.y = 0.3;
                    }
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keyboard[e.code] = false;
            });
            
            // Mouse click handler
            window.addEventListener('mousedown', onMouseDown);
            
            // Prevent right-click menu
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Start animation loop
            animate();
            
            // Update chunk count in UI
            updateStatsUI();
        }
        
        function startGame() {
            gameStarted = true;
            controls.lock();
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function generateWorld() {
            // Generate terrain
            for (let x = 0; x < WORLD_SIZE; x++) {
                for (let z = 0; z < WORLD_SIZE; z++) {
                    const height = Math.max(
                        5, 
                        10 + Math.sin(x * 0.1) * 3 + 
                          Math.sin(z * 0.2) * 2 + 
                          Math.sin((x + z) * 0.05) * 4
                    );
                    
                    // Surface blocks
                    addBlock(x, height, z, 'grass');
                    
                    // Sub-surface blocks
                    for (let y = height - 1; y > height - 3; y--) {
                        addBlock(x, y, z, 'dirt');
                    }
                    
                    for (let y = height - 3; y > 0; y--) {
                        if (Math.random() > 0.92) addBlock(x, y, z, 'sand');
                        else if (Math.random() > 0.98) addBlock(x, y, z, 'diamond');
                        else addBlock(x, y, z, 'stone');
                    }
                    
                    // Water bodies
                    for (let y = 0; y < 5; y++) {
                        const waterMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE),
                            new THREE.MeshLambertMaterial({ 
                                color: 0x0066cc,
                                transparent: true,
                                opacity: 0.7 
                            })
                        );
                        waterMesh.position.set(x, y, z);
                        scene.add(waterMesh);
                    }
                    
                    // Generate trees
                    if (x > 5 && x < WORLD_SIZE - 5 && z > 5 && z < WORLD_SIZE - 5 && Math.random() > 0.96) {
                        createTree(x, height + 1, z);
                    }
                }
            }
            
            // Generate mountains
            createMountain(15, 30, 15, 15, 'stone');
            createMountain(45, 35, 45, 18, 'stone');
            
            // Add monsters
            for (let i = 0; i < 10; i++) {
                addMonster(
                    Math.random() * WORLD_SIZE,
                    30,
                    Math.random() * WORLD_SIZE
                );
            }
        }
        
        function createSky() {
            const skyGeometry = new THREE.SphereGeometry(500, 60, 60);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: dayTime ? 0x87CEEB : 0x0c1445,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }
        
        function createTree(x, y, z) {
            // Tree trunk
            const trunkHeight = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < trunkHeight; i++) {
                addBlock(x, y + i, z, 'wood');
            }
            
            // Tree leaves
            const top = y + trunkHeight;
            for (let dx = -2; dx <= 2; dx++) {
                for (let dz = -2; dz <= 2; dz++) {
                    for (let dy = 0; dy < 3; dy++) {
                        // Skip some cubes to create a natural shape
                        if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && dy !== 1) continue;
                        if (Math.random() > 0.6) addBlock(x + dx, top + dy, z + dz, 'grass');
                    }
                }
            }
        }
        
        function createMountain(x, y, z, height, type) {
            for (let h = 0; h < height; h++) {
                const radius = (height - h) * 1.5;
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dz = -radius; dz <= radius; dz++) {
                        const dist = dx*dx + dz*dz;
                        if (dist < radius*radius) {
                            const heightVariation = (Math.sin(dx)*0.5 + Math.cos(dz)*0.5) / 2;
                            addBlock(x + dx, y + h + heightVariation, z + dz, type);
                        }
                    }
                }
            }
        }
        
        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if (world[key]) return;
            
            // Create block
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const material = new THREE.MeshLambertMaterial({ 
                color: BLOCK_DATA[type]?.color || 0xffffff 
            });
            
            const block = new THREE.Mesh(geometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;
            block.receiveShadow = true;
            scene.add(block);
            
            // Store block in world
            world[key] = {
                mesh: block,
                type: type,
                x: x, 
                y: y, 
                z: z 
            };
            
            chunksLoaded++;
            updateStatsUI();
        }
        
        function addMonster(x, y, z) {
            const size = 1.5;
            const bodyGeometry = new THREE.BoxGeometry(size * 0.7, size, size * 0.7);
            const color = new THREE.Color(
                0.2 + Math.random() * 0.3,
                0.2 + Math.random() * 0.3,
                0.3 + Math.random() * 0.3
            );
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                emissive: new THREE.Color(color).multiplyScalar(0.1)
            });
            
            const mob = new THREE.Mesh(bodyGeometry, material);
            mob.position.set(x, y, z);
            mob.castShadow = true;
            mob.receiveShadow = true;
            scene.add(mob);
            
            // Add eyes
            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(size * 0.2, size * 0.15, size * 0.4);
            mob.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-size * 0.2, size * 0.15, size * 0.4);
            mob.add(rightEye);
            
            mobs.push({ 
                mesh: mob,
                health: 80 + Math.floor(Math.random() * 40),
                originalHealth: 100,
                speed: Math.random() * 0.03 + 0.02,
                damage: 5 + Math.floor(Math.random() * 10)
            });
            
            mobsCount++;
            updateStatsUI();
        }
        
        function updatePlayerPosition(delta) {
            // Handle player movement
            const speedMultiplier = keyboard['ShiftLeft'] ? 1.8 : 1;
            let moveX = 0, moveZ = 0;
            
            if (keyboard['KeyW']) moveZ = -delta * 10 * speedMultiplier;
            if (keyboard['KeyS']) moveZ = delta * 10 * speedMultiplier;
            if (keyboard['KeyA']) moveX = -delta * 10 * speedMultiplier;
            if (keyboard['KeyD']) moveX = delta * 10 * speedMultiplier;
            
            // Update position
            camera.translateX(moveX);
            camera.translateZ(moveZ);
        }
        
        function onMouseDown(e) {
            if (!controls.isLocked) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            if (currentBlockType === 'sword') {
                handleSwordAttack();
                return;
            }
            
            // Handle block interaction
            const intersects = raycaster.intersectObjects(Object.values(world).map(b => b.mesh));
            if (intersects.length === 0) return;
            
            const { point, face, object } = intersects[0];
            const x = Math.round(object.position.x);
            const y = Math.round(object.position.y);
            const z = Math.round(object.position.z);
            const blockKey = `${x},${y},${z}`;
            const block = world[blockKey];
            
            if (!block) return;
            
            if (e.button === 0) { 
                // Destroy block on left click
                removeBlock(block);
            } else if (e.button === 2) { 
                // Place block on right click
                const faceNormal = face.normal;
                const newX = Math.round(x + faceNormal.x);
                const newY = Math.round(y + faceNormal.y);
                const newZ = Math.round(z + faceNormal.z);
                addBlock(newX, newY, newZ, currentBlockType);
                blocksPlaced++;
                updateStatsUI();
            }
        }
        
        function handleSwordAttack() {
            if (attackCooldown > 0) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(mobs.map(m => m.mesh));
            
            if (intersects.length > 0) {
                const mobObject = intersects[0].object;
                const mob = mobs.find(m => m.mesh === mobObject || m.mesh.children.includes(mobObject));
                
                if (mob) {
                    // Apply damage to mob
                    const damage = 15 + Math.floor(Math.random() * 20);
                    mob.health -= damage;
                    
                    // Show damage indicator
                    const damageElem = document.createElement('div');
                    damageElem.className = 'damage';
                    damageElem.textContent = `-${damage}`;
                    damageElem.style.left = `${50 + (Math.random() - 0.5) * 30}%`;
                    damageElem.style.top = `${50 + (Math.random() * 20)}%`;
                    document.getElementById('ui').appendChild(damageElem);
                    
                    // Remove damage indicator after animation
                    setTimeout(() => {
                        if (damageElem.parentNode) {
                            damageElem.parentNode.removeChild(damageElem);
                        }
                    }, 1500);
                    
                    // Update mob UI
                    document.getElementById('mob-health').style.display = 'block';
                    document.getElementById('mob-health-value').textContent = `${Math.max(0, Math.floor(mob.health / mob.originalHealth * 100))}%`;
                    
                    // Check if mob died
                    if (mob.health <= 0) {
                        scene.remove(mob.mesh);
                        mobs.splice(mobs.indexOf(mob), 1);
                        
                        // Grant XP to player
                        const xpGained = 10 + Math.floor(Math.random() * 15);
                        addExp(xpGained);
                        
                        document.getElementById('mob-health').style.display = 'none';
                        mobsCount--;
                        updateStatsUI();
                        
                        // Sometimes spawn a new monster
                        if (mobs.length < 15 && Math.random() > 0.5) {
                            const cameraPos = camera.position;
                            addMonster(
                                cameraPos.x + (Math.random() - 0.5) * 30,
                                cameraPos.y,
                                cameraPos.z + (Math.random() - 0.5) * 30
                            );
                        }
                    }
                    
                    // Attack cooldown
                    attackCooldown = 0.5;
                }
            }
        }
        
        function addExp(amount) {
            playerExp += amount;
            if (playerExp >= expToNextLevel) {
                playerExp = playerExp - expToNextLevel;
                playerLevel++;
                expToNextLevel = Math.floor(expToNextLevel * 1.3);
                document.getElementById('level').textContent = `Level ${playerLevel}`;
            }
            
            const expPercent = (playerExp / expToNextLevel) * 100;
            document.getElementById('exp-fill').style.width = `${expPercent}%`;
        }
        
        function animateDayNight(delta) {
            // Toggle day/night every 30 seconds
            if (Math.sin(clock.elapsedTime * 0.1) > 0) {
                if (!dayTime) {
                    dayTime = true;
                    document.getElementById('time-text').textContent = 'Day';
                    document.querySelector('.time-icon').textContent = '‚òÄÔ∏è';
                    scene.background = new THREE.Color(0x87CEEB);
                    sun.visible = true;
                    moon.visible = false;
                }
            } else {
                if (dayTime) {
                    dayTime = false;
                    document.getElementById('time-text').textContent = 'Night';
                    document.querySelector('.time-icon').textContent = 'üåô';
                    scene.background = new THREE.Color(0x0c1445);
                    sun.visible = false;
                    moon.visible = true;
                }
            }
        }
        
        function updateStatsUI() {
            document.getElementById('chunk-count').textContent = chunksLoaded;
            document.getElementById('blocks-count').textContent = blocksPlaced;
            document.getElementById('mobs-count').textContent = mobsCount;
        }
        
        function updateMonsterAI(delta) {
            mobs.forEach(mob => {
                if (!mob.mesh) return;
                
                // Get the mob position
                const mobPos = mob.mesh.position;
                
                // Calculate direction to player
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, mobPos).normalize();
                
                // Move towards the player
                mob.mesh.position.add(direction.multiplyScalar(mob.speed * delta * 30));
                
                // Rotate to face player
                mob.mesh.lookAt(camera.position);
                
                // Maintain vertical alignment
                mob.mesh.rotation.x = 0;
                mob.mesh.rotation.z = 0;
                
                // Check for collision with player
                const distance = mobPos.distanceTo(camera.position);
                if (distance < 2) {
                    playerHealth -= mob.damage * delta;
                    document.getElementById('health-fill').style.width = `${Math.max(0, playerHealth)}%`;
                    
                    if (playerHealth <= 0) {
                        // Player died - reset
                        playerHealth = 100;
                        document.getElementById('health-fill').style.width = `100%`;
                        camera.position.set(32, 20, 32);
                    }
                }
            });
        }
        
        function showBlockName(name) {
            const nameElem = document.getElementById('block-name');
            nameElem.textContent = name;
            nameElem.style.opacity = 1;
            
            setTimeout(() => {
                nameElem.style.opacity = 0;
            }, 2000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(0.1, clock.getDelta());
            
            // UI animations
            document.getElementById('level').textContent = `Level ${playerLevel}`;
            
            if (!controls.isLocked) {
                // Pre-game animations
                const camPos = camera.position;
                const time = clock.getElapsedTime();
                camPos.x = 32 + Math.sin(time * 0.2) * 10;
                camPos.z = 32 + Math.cos(time * 0.3) * 10;
                camera.lookAt(WORLD_SIZE/2, 10, WORLD_SIZE/2);
                renderer.render(scene, camera);
                return;
            }
            
            // Gameplay updates
            updatePlayerPosition(delta);
            updateMonsterAI(delta);
            animateDayNight(delta);
            
            // Apply gravity
            playerVelocity.y -= 0.005;
            camera.position.y += playerVelocity.y;
            
            // Ground collision detection
            raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
            const groundHit = raycaster.intersectObjects(Object.values(world).map(b => b.mesh))[0];
            if (groundHit && groundHit.distance < 2) {
                camera.position.y = groundHit.point.y + 1.8;
                playerVelocity.y = Math.max(0, playerVelocity.y);
            }
            
            // Constrain player to map
            camera.position.x = Math.max(1, Math.min(WORLD_SIZE - 1, camera.position.x));
            camera.position.y = Math.max(1, Math.min(80, camera.position.y));
            camera.position.z = Math.max(1, Math.min(WORLD_SIZE - 1, camera.position.z));
            
            // Reduce attack cooldown
            if (attackCooldown > 0) attackCooldown -= delta;
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>